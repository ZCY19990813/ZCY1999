## 题目来源：[力扣60 第k个排列](https://leetcode-cn.com/problems/permutation-sequence/)

## 战绩：执行用时 : 4ms, 在所有 C++ 提交中击败了 76.38%的用户。内存消耗 :8.3 MB, 在所有 C++ 提交中击败了27.09 %的用户

## 题意：给出集合 [1,2,3,…,n]，其所有元素共有n! 种排列。按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下："123""132""213""231""312""321".给定 n 和 k，返回第 k 个排列。

## 说明：给定 n 的范围是 [1, 9]。给定 k 的范围是[1,  n!]。

### 输入：n=3,k=3 输出："213"

### 思路：直接找到第k个排列
  - 考虑到我们的目标仅仅是找到第k个排列，有没有办法不用列举中间的排列，直接根据输入信息和排列规律直接找到第k个排列？
  - 在n个数字的排列中，根据手动排列的习惯，先固定第一个位置的数字，还剩下最多(n-1)!种排列，再由放到第一个位置的数字原先的位置i(从左往右第i个)的不同，表示跳过了i(n-1)种排列。要找到第k个排列，先由i = k/(n-1)得出应该移到第一个位置的数字索引，并由k = k%(n - 1)更新k.*
  - 这样，我们可以从左往右遍历原先字符串的最小排列，每一次找到应该放在左边第一个位置的数字，将其添加到结果字符串中，并从原字符串中删除，然后对剩下的字符串重复这一操作，直到k==0。此外由于字符串最初的状态就是第１个排列，所以要将输入的k先减一。

### AC代码：

```
class Solution {
public:
    string getPermutation(int n, int k) {
        string s="123456789";
        string ans="";
        int fac[10]={0,1};
        for(int i=2;i<=9;i++)
          fac[i]=fac[i-1]*i;
        s=s.substr(0,n);
        k--;
        while(k>0){
            int p=k/fac[n-1];
            int q=k%fac[n-1];
            ans+=s[p];
            s.erase(s.begin()+p);
            //cout<<p<<" "<<q<<" "<<ans<<" "<<s<<endl;
            k=q;
            n--;
        }
        return ans+s;
    }
};
```

