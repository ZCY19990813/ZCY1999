## 题目来源：[力扣136 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)

## 战绩：执行用时 : 8ms, 在所有 C++ 提交中击败了 99.32的用户。内存消耗 : 9.8MB, 在所有 C++ 提交中击败了25.48 的用户.

## 题意：给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。说明：你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？

### 输入：[4,2,1,2,1] 输出：4

### 思路：
  - 这题拿到手，第一反应是用hash表，没有思考细节，只是觉得hash表肯定是可以搞定的，但是空间复杂度是 O(n)，不满足题意。
  - 接着开始思考，如何才能做到空间复杂度是 O(1) 呢？脑袋开始疯狂打转，但没有思路。没办法，退回原点。
  - 心想，如果使用暴力破解法，该如何解决，很简单：每次从数组中取一个数，记为cur，然后从剩下的数中查找，如果找不到，则cur即为要找的那个数。这种解法时间复杂度是 O(n^2)
  - 继续思考，如何再继续降低复杂度呢？ 想到了排序 ！！！
  - 再继续思考，如何能把时间复杂度降到 O(n)O(n)，有两个突破点：
  - 暴力解法做了很多重复的工作,要充分利用题目的已有信息.通过第一点，我没有想到思路，不知道有没有 DP 的解法，可能本人对DP使用不是太熟。通过第二点，我还真找到突破口。反复看了好几篇题目，找到了一个很重要的信息：除了某个元素只出现一次以外，其余每个元素均出现两次。 觉得这是个突破口！！！！——异或运算！

### AC代码：

```
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        if(nums.size()==0)
            return 0;
        int ans=nums[0];
        for(int i=1;i<nums.size();i++)
            ans^=nums[i];
        return ans;
    }
};
```

