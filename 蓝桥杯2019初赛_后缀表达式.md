## 题目来源：[蓝桥杯2019初赛_后缀表达式](http://oj.ecustacm.cn/problem.php?id=1467)

## 题意：给定N 个加号、M 个减号以及N + M + 1 个整数A1,A2,...,AN+M+1
小明想知道在所有由这N 个加号、M 个减号以及N + M +1 个整数凑出的合法的后缀表达式中，结果最大的是哪一个？请你输出这个最大的结果。例如使用1 2 3 + -，则“2 3 + 1 -” 这个后缀表达式结果是4，是最大的。

### 输入：3 3 -2 -1 -1 -1 -1 -1 -1 输出：6

### 思路：这个题目的一大坑点是后缀表达式是可以加括号的，意思也就是，可以将负号变为正号。
-- 例如：n=1,m=1，数组元素依次为-1,-2,3，最终结果为3-((-1)+(-2))。而不是3+(-1)-(-2)。
-- 明白了这一点我们就要考虑负数和所有数的关系了。
-- 如果有负数存在的话：
-- ①如果负数的个数num不等于n+m+1的话，我们是可以通过加括号的形式，将所有的减号变为加号的。
-- ②如果负数的个数num等于n+m+1的话，肯定会留出一个负数来，无法通过加括号的形式变为正的，那么就只能加上这个负数，贪心去想，肯定是负数中最大的那个。
-- 如果说没有负数的话，那么只能减去最小的那个数，剩下的就可以通过加括号的形式变为加了。

### AC代码：

```
#include<iostream>
#include<bits/stdc++.h>
using namespace std;
int a[200100];
int main()
{
    int n,m,num=0;//num代表负数的个数
    long long ans=0;
    scanf("%d%d",&n,&m);
    int length=n+m+1;
    for(int i=0;i<length;i++){
        scanf("%d",&a[i]);
        if(a[i]<0)
            num++;
    }
    sort(a,a+length);
    for(int i=0;i<length;i++){
        ans+=a[i];
    }
    if(m==0){
        cout<<ans<<endl;
        return 0;
    }
    if(num){
        if(num!=length)
            for(int i=0;i<num;i++)
                ans-=2*a[i];
        else
            for(int i=0;i<num-1;i++)
                ans-=2*a[i];
    }
    else
        ans-=2*a[0];//***
    /*1 2
      1 2 3 4
     正确的顺序应该是
     4+3-（1-2）=4+3+2-1
     也就是说等等价于只有一个负号起到了作用，其余的负号全部负负得正
    */
    printf("%lld\n",ans);
    return 0;
}

```

